# Домашнее задание к уроку 9. #   
1. В Yandex-Cloud от выполнения первого дз у меня осталась виртуальная машина и установленный PostgreSQL 15.   
![Шаг4](/4_1_OldVM.jpg)  
1. Посмотрела текущие настройки   
![Шаг4](/9_1_params_log.jpg)  
1. Включила параметр для сброса информации о блокировках в журнал (log_lock_waits)   
![Шаг4](/9_2_log_lock_waits.jpg)  
1. Проверила параметр log_lock_waits. Включен.   
![Шаг4](/9_3_params_log_on.jpg)  
1. Настроила порог сброса данных о блокировках в 200 миллисекунд.   
![Шаг4](/9_4_200ms.jpg)  
1. Создала базу данных и таблицу для тестирования блокировок.      
![Шаг4](/9_5_before_test1.jpg)  
1. Запустила в первом окне явную транзакцию через begin и апдейт на таблицу bl_testing. Запустила второе окно Putty и сделала апдейт на ту же строку таблицы bl_testing. В первом окне апдейт выполнен, но не подтвержден. Сессия во втором окне заблокирована. Сделала для надежности паузу в 1 секунду.     
![Шаг4](/9_6_test1.jpg)  
1. Сделала commit сначала в первом окне, тогда во втором окне выполнился апдейт, тоже сделала коммит.      
![Шаг4](/9_7_after_test1.jpg)  
1. Посмотрела журнал сообщений. Информация о блокировке есть.      
![Шаг4](/9_8_show_log_file.jpg)  


Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.
