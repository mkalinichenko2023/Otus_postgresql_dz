# Домашнее задание к уроку 9. #   
1. В Yandex-Cloud от выполнения первого дз у меня осталась виртуальная машина и установленный PostgreSQL 15.   
![Шаг4](/4_1_OldVM.jpg)  
1. Посмотрела текущие настройки   
![Шаг4](/9_1_params_log.jpg)  
1. Включила параметр для сброса информации о блокировках в журнал (log_lock_waits)   
![Шаг4](/9_2_log_lock_waits.jpg)  
1. Проверила параметр log_lock_waits. Включен.   
![Шаг4](/9_3_params_log_on.jpg)  
1. Настроила порог сброса данных о блокировках в 200 миллисекунд.   
![Шаг4](/9_4_200ms.jpg)  
1. Создала базу данных и таблицу для тестирования блокировок.      
![Шаг4](/9_5_before_test1.jpg)  
1. Запустила в первом окне явную транзакцию через begin и апдейт на таблицу bl_testing. Запустила второе окно Putty и сделала апдейт на ту же строку таблицы bl_testing. В первом окне апдейт выполнен, но не подтвержден. Сессия во втором окне заблокирована. Сделала для надежности паузу в 1 секунду.     
![Шаг4](/9_6_test1.jpg)  
1. Сделала commit сначала в первом окне, тогда во втором окне выполнился апдейт, тоже сделала коммит.      
![Шаг4](/9_7_after_test1.jpg)  
1. Посмотрела журнал сообщений. Информация о блокировке есть.      
![Шаг4](/9_8_log_file.jpg)  
1. Запустила update одной и той же строки в трех разных окнах Putty. Сделала выборку из pg_locks, отсортированную по pid и locktype.   
![Шаг4](/9_12_test2_pg_locks.jpg)  
На скрине видно, что транзакциям при старте были присвоены виртуальные номера virtualxid 7/10, 3/1145, 4/282 в режиме ExclusiveLock (исключительной блокировки). Также транзакции дополнительно получили физические номера transactionid 780, 781 и 782 аналогично в режиме ExclusiveLock. Последовательные команды update привели к появению блокировок с типом relation (блокировка отношений) на таблицу bl_testing в режиме RowExclusiveLock (эксклюзивная блокировка строки). Сессия с pid=18059 попыталась получить блокировку с номером transactionid=780 (процесс pid=18056) в режиме ShareLock, но неудачно (granted=f) и наложила блокировку tuple (блокировка версии строки) на обновляемую строку таблицы в режиме ExclusiveLock. Сессия с pid=18065, как третья в очереди на апдейт строки попыталась наложить блокировку tuple (блокировка версии строки) на обновляемую строку таблицы в режиме ExclusiveLock, но неудачно (granted=f). Столбец waitstart показывает время начала блокирования транзакций.
1. Сделала commit  поочередно во всех трех окнах. Сделала выборку из pg_locks, блокировки ушли.       
![Шаг4](/9_13_test2_after.jpg)  
1. Посмотрела в журнале сообщений информацию о блокировках. Видна информация о блокировке процессов 18059 и 18065.   
![Шаг4](/9_14_test2_log_file.jpg)  
1. Для получения ситуации взаимоблокировки трех транзакций создала таблицу tst_balance с тремя строками и подготовила команды update в трех окнах Putty:  
![Шаг4](/9_15_before_test3.jpg)  
В первом окне прошел апдейт строки 1, во втором окне прошел апдейт строки 2, в терьем окне прошел апдейт строки 3. Все транзакции незавершенные, коммитов не было.  
![Шаг4](/9_16_test3_1.jpg)  
Теперь в первом окне готовим апдейт на строку 2, во втором на строку 3, а в третьем окне на строку 1.   
![Шаг4](/9_16_test3_2.jpg)  
Выполняем апдейт последовательно с 1го по 3е окна. Получаем ошибку в третьем окне при попытке обновить строку 1.
![Шаг4](/9_16_test3_3.jpg)  
ERROR:  deadlock detected   
DETAIL:  Process 20124 waits for ShareLock on transaction 787; blocked by process 19952.   
Process 19952 waits for ShareLock on transaction 788; blocked by process 20055.   
Process 20055 waits for ShareLock on transaction 789; blocked by process 20124.   
HINT:  See server log for query details.   
CONTEXT:  while updating tuple (0,1) in relation "tst_balance"   
Сделаем commit  снача в 3ем окне (получим rollback по факиу), потом во 2ом - успешный коммит, потом в 1-ом тоже успешный соммит.   
![Шаг4](/9_16_test3_4.jpg)  
1. 
![Шаг4](/9_16_test3_4.jpg)  

Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.
