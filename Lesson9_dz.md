# Домашнее задание к уроку 9. #   
1. В Yandex-Cloud от выполнения первого дз у меня осталась виртуальная машина и установленный PostgreSQL 15.   
![Шаг4](/4_1_OldVM.jpg)  
1. Посмотрела текущие настройки   
![Шаг4](/9_1_params_log.jpg)  
1. Включила параметр для сброса информации о блокировках в журнал (log_lock_waits)   
![Шаг4](/9_2_log_lock_waits.jpg)  
1. Проверила параметр log_lock_waits. Включен.   
![Шаг4](/9_3_params_log_on.jpg)  
1. Настроила порог сброса данных о блокировках в 200 миллисекунд.   
![Шаг4](/9_4_200ms.jpg)  
1. Создала базу данных и таблицу для тестирования блокировок.      
![Шаг4](/9_5_before_test1.jpg)  
1. Запустила в первом окне явную транзакцию через begin и апдейт на таблицу bl_testing. Запустила второе окно Putty и сделала апдейт на ту же строку таблицы bl_testing. В первом окне апдейт выполнен, но не подтвержден. Сессия во втором окне заблокирована. Сделала для надежности паузу в 1 секунду.     
![Шаг4](/9_6_test1.jpg)  
1. Сделала commit сначала в первом окне, тогда во втором окне выполнился апдейт, тоже сделала коммит.      
![Шаг4](/9_7_after_test1.jpg)  
1. Посмотрела журнал сообщений. Информация о блокировке есть.      
![Шаг4](/9_8_log_file.jpg)  
1. Запустила update одной и той же строки в трех разных окнах Putty. Сделала выборку из pg_locks, отсортированную по pid и locktype.   
![Шаг4](/9_12_test2_pg_locks.jpg)  
На скрине видно, что транзакциям при старте были присвоены виртуальные номера virtualxid 7/10, 3/1145, 4/282 в режиме ExclusiveLock (исключительной блокировки). Также транзакции дополнительно получили физические номера transactionid 780, 781 и 782 аналогично в режиме ExclusiveLock. Последовательные команды update привели к появению блокировок с типом relation (блокировка отношений) на таблицу bl_testing в режиме RowExclusiveLock (эксклюзивная блокировка строки). Сессия с pid=18059 попыталась получить блокировку номера transactionid=780 (процесс pid=18056) в режиме ShareLock, но неудачно (granted=f) и наложила (granted=t) блокировку tuple (блокировка версии строки) на обновляемую строку таблицы в режиме ExclusiveLock (строка 8)
1. Сделала commit  поочередно во всех трех окнах. Сделала выборку из pg_locks, блокировки ушли.       
![Шаг4](/9_13_test2_after.jpg)  
1. Посмотрела в журнале сообщений информацию о блокировках. Видна информация о блокировке процессов 18059 и 18065.   
![Шаг4](/9_14_test2_log_file.jpg)  


Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая.
Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?
Задание со звездочкой*
Попробуйте воспроизвести такую ситуацию.
